var e;!function(e){e.Fencing="fencing",e.HeaderPrimaryKey="headerPrimary",e.HeaderSecondaryKey="headerSecondary",e.Highlight="highlight",e.Bold="bold",e.Redact="redact",e.Interrupt="interrupt"}(e||(e={}));const t=Object.fromEntries(new Map([[e.Fencing,{key:"`",repeated:3,rule:e.Fencing}],[e.HeaderPrimaryKey,{key:"\\-",repeated:3,rule:e.HeaderPrimaryKey}],[e.HeaderSecondaryKey,{key:"\\=",repeated:3,rule:e.HeaderSecondaryKey}],[e.Highlight,{key:"\\`",repeated:2,rule:e.Highlight}],[e.Bold,{key:"\\*",repeated:2,rule:e.Bold}],[e.Redact,{key:"\\~",repeated:2,rule:e.Redact}],[e.Interrupt,{key:"\\",repeated:2,rule:e.Interrupt}]]));class r{source;opts;expr;groups;constructor(e,t=""){this.source="string"==typeof e?e:e.source,this.opts=t,this.expr=void 0,this.groups={}}replace(e,t){let r="string"==typeof t?t:t.source;return r=r.replace(n,"$1"),this.source=this.source.replaceAll(e,r),this}createRegex(e={}){return this.expr=new RegExp(this.source,this.opts),this.groups=e,this}get regex(){return this.expr||this.createRegex(),this.expr?this.expr:/()/}}const n=/(^|[^\[])\^/g;var i,a;!function(e){e.TYPE="TYPE",e.RESULT="RESULT"}(i||(i={})),function(e){e.AllowableSpace="AllowableSpace",e.Fencing="Fencing",e.HeadingSect="HeadingSect",e.TextBlock="TextBlock",e.Paragraph="Paragraph",e.Highlight="Highlight",e.Span="Span"}(a||(a={}));class l{blockRules;inlineRules;constructor(n=t){this.blockRules=function(t){const n=`${t[e.Fencing].key}{${t[e.Fencing].repeated}}`,l=`${t[e.HeaderPrimaryKey].key}{${t[e.HeaderPrimaryKey].repeated}}`,s=`${t[e.HeaderSecondaryKey].key}{${t[e.HeaderPrimaryKey].repeated}}`,o=/\n|$/,c=new r(/ *?(EndOfLine%)/).replace("EndOfLine%",o).createRegex(),h=new r(/HeaderPrimaryKey%|HeaderSecondaryKey%/).replace("HeaderPrimaryKey%",l).replace("HeaderSecondaryKey%",s).createRegex();return Object.fromEntries(new Map([[a.AllowableSpace,{patterns:new r(/^(?<RESULT>AllowableSpace%)/).replace("AllowableSpace%",c.regex).createRegex({[i.RESULT]:1}),hasTokens:!1}],[a.Fencing,{patterns:new r(/^(?<TYPE>FencingKey%)(?<RESULT>AllContainedChar%|$)(?:FencingKey%)/).replace("FencingKey%",n).replace("AllContainedChar%",/[\s\S]*?/).createRegex({[i.TYPE]:1,[i.RESULT]:2}),hasTokens:!0}],[a.HeadingSect,{patterns:new r(/^(?<RESULT>EmptySurronding%|.+\n)(?<TYPE>SectionHeader%)(?:EndOfLine%)/).replace("SectionHeader%",h.regex).replace("EmptySurronding%",/\n(?!\s*?\n)/).replace("EndOfLine%",o).createRegex({[i.RESULT]:1,[i.TYPE]:2}),hasTokens:!1}],[a.TextBlock,{patterns:new r(/^(?<RESULT>AllCharInLine%AllowableSpace%)/).replace("AllowableSpace%",c.regex).replace("AllCharInLine%",/[^\n]+/).createRegex({[i.RESULT]:1}),hasTokens:!0}]]))}(n),this.inlineRules=function(t){const n=`${t[e.Bold].key}{${t[e.Bold].repeated}}`,l=`${t[e.Redact].key}{${t[e.Redact].repeated}}`,s=(t[e.Interrupt].key,t[e.Interrupt].repeated,`${t[e.Highlight].key}{${t[e.Highlight].repeated}}`),o=new r(/Bold%|Redact%/).replace("Bold%",n).replace("Redact%",l).createRegex();return Object.fromEntries(new Map([[a.Paragraph,{patterns:new r(/^(?!HighlightKey%|Spanable%)(?<RESULT>[\s\S]*?)(?=HighlightKey%|Spanable%|$)/).replace("Spanable%",o.regex).replace("HighlightKey%",s).createRegex({[i.RESULT]:1}),hasTokens:!1}],[a.Highlight,{patterns:new r(/(HighlightKey%)(?:\~(?<TYPE>\S*) ?|)(?<RESULT>[\s\S]*?)(\1)/).replace("HighlightKey%",s).createRegex({[i.TYPE]:2,[i.RESULT]:3}),hasTokens:!0}],[a.Span,{patterns:new r(/(?<TYPE>Spanable%)(?<RESULT>[\s\S]*?)\1/).replace("Spanable%",o.regex).createRegex({[i.TYPE]:1,[i.RESULT]:2}),hasTokens:!1}]]))}(n)}tokenize(e,t,r,n,i){const a=e?.groups?e.groups?.RESULT||e[r.RESULT]||"null":e[r.RESULT]||e[1],l=e?.groups?e.groups?.TYPE||e[r.TYPE]||"null":e[r.TYPE]||"";return{keyName:t,raw:i?(i?.raw||"")+e[0]:e[0],text:i?(i?.text||"")+(a||""):a||"",depth:n,type:l}}}class s{Tokenizer;inlineQueue;constructor(e=t){Array.isArray(e)&&(e=function(...e){const t=new Map;for(let r=0;r<e.length;r++)t.set(e[r].rule,e[r]);return Object.fromEntries(t)}(...e));const r=Object.assign(Object.assign({},t),e);this.Tokenizer=new l(r),this.inlineQueue=[]}lexalizeFrom(e,t,r=this.Tokenizer.blockRules,n,i,l){const s=Object.keys(r),o=s.length;let c,h=l||0;for(let l=i||0;l<o;l++){const i=s[l],o=r[i];if((c=o.patterns.regex.exec(t))&&c[0].length>0){let s,p;n?(n?.children||(n.children=new Array),p=n.children):p=e;const g=p?.length-1||0,d=p[g>=0?g:0];d&&d.keyName==i?(s=this.Tokenizer.tokenize(c,i,o.patterns.groups,h,d),p.pop(),o?.hasTokens&&this.inlineQueue.pop()):s=this.Tokenizer.tokenize(c,i,o.patterns.groups,h),o?.hasTokens&&(a.Paragraph in r?this.lexalizeFrom(e,s.text,r,s,0,h+1):this.inlineQueue.push(s)),p.push(s),t=t.substring(c[0].length),l=-1}}if(a.TextBlock in r)for(let t=0;t<this.inlineQueue.length;t++)this.lexalizeFrom(e,this.inlineQueue[t].text,this.Tokenizer.inlineRules,this.inlineQueue[t],0,1)}}class o{tokens;interpretter;constructor(e){this.tokens=[],this.interpretter=new s(e)}parse(e,t){return this.tokens=[],e=e.trim(),this.interpretter.lexalizeFrom(this.tokens,e),this.tokens}*iterateTokensHelper(e,t={getAll:!0}){if(e){if(e.length<1)return}else{if(!(this.tokens.length>0))return;e=this.tokens}for(let r=0;r<e.length;r++)t?.getAll&&(yield e[r]),e[r]?.children?yield*this.iterateTokensHelper(e[r].children,t):t?.getAll||(yield e[r])}*getOrderedChildren(){for(const e of this.iterateTokensHelper(this.tokens,{getAll:!1}))yield e}*getTokenTree(){for(const e of this.iterateTokensHelper(this.tokens,{getAll:!0}))yield e}getStringArray(){const e=new Array;return this.iterateTokens((t=>{if(t?.children){const r=t.children.length;for(let n=0;n<r;n++)e.push(t.children[n].text)}else e.push(t.text)})),e}iterateTokens(e,t={fromIter:0,callWithParents:!1},r){if(r){if(r.length<1)return}else{if(!(this.tokens.length>0))return;r=this.tokens}for(let n=t.fromIter||0;n<r.length;n++)t.callWithParents&&e(r[n]),r[n]?.children?this.iterateTokens(e,{...t,fromIter:0},r[n].children):t.callWithParents||e(r[n])}}export{o as KeyCodeParser};