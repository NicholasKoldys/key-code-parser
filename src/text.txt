    console.log('\nStarting: block \n\n');
        let initTime = Date.now();


    console.log('Duration: ', initTime, ' > ', (Date.now() - initTime));
    // console.log("FinishedArray: ", this.tokens);
    // console.log("CurrentInlineQue: ", this.inlineQueue);
    
    console.log('Starting: inline \n\n\n\n');
        console.log('Duration: ', initTime, ' > ', (Date.now() - initTime));



/* function preProcesser(src: string) {
  src = src.replace(/\r\n|\r/g, 'x\n'); //Standardize line breaks

  if (!null) { // this.options.pedantic 
    src = src.replace(/\t/g, '    ').replace(/^ +$/gm, '');// keep tabs remove single_spaces
  } else {
    src = src.replace(/^( *)(\t+)/gm, (_, leading, tabs) => {// make all tabs spaces
      return leading + 't    '.repeat(tabs.length);
    });
  }
} */


// let stringTest = "loging a \"test\" ``` ``` 'string' withescaped \'\'\"\" quotes";

// TestsOf({
//   'keysTest': () => {
//     assertEquals(tokenKeys.keys.escape.key, '\\', 'is escape keyValue');
//   }
// });



/* //* Why do I want to do this,
  I saw markdown and wanted to use its ease of styling, but I dont want to convert to only html,
  I would like to convert multiple xml formated ways, but make it the end users responsibility to manipulate
  the end product.

  For instance, blocks can be styled with ReactNative Views and appended with styles in code.
 */

/* TODO
  // To avoid parsing multiple times, text input needs to be replaced with a structural tree of nodes,
  // "text" will be converted into and array in order, holding the value of the input as an object
  // {
  //   style: ["\"", ]
  //   text: text
  // }
  instead of storing structure, mkd can be parsed everytime the note card shows.

  The parsed text will return a list of text serialized with supplied token keys.
  This list can be saved. or recalced based on a score, to keep or reiterate.

  // Parse input string seperate out with marked style regex

  Parse text for defining tokens
  place in a list

  with list restyle components into react components
 */

// const levelOfimportance = {
//   extensions,
//   space,
//   code,
//   fences,
//   heading,
//   hr,
//   blockquote,
//   list,
//   html,
//   def, //definition
//   table,
//   lheading,
//   text,
//   infLoop,//breakout

//   //inline Level
//   link, //maskout
//   reflinkSearch,
//   blockskip,
//   punctuation,
//   extensions,
//   escape,
//   tag,
//   link,
//   reflink,
//   emStrong,
//   codespan,
//   br,
//   del,
//   autoLink,
//   url,
//   extText,
//   text,
//   infLoop //breakout
// }

  /* I can put an interrupt here and the say its text for the reiter loop
  or we use the deliminator method for the highlight... We take the beginning char and allow interrupt,
  then the take the remaining. @Start we grab all char - then interrupt - the container will be the highlight token so all the tokens will be added.  */